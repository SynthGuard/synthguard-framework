apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: transaction-pipeline-
  annotations: {pipelines.kubeflow.org/kfp_sdk_version: 1.8.0, pipelines.kubeflow.org/pipeline_compilation_time: '2024-07-25T09:58:19.720868',
    pipelines.kubeflow.org/pipeline_spec: '{"name": "transaction pipeline"}'}
  labels: {pipelines.kubeflow.org/kfp_sdk_version: 1.8.0}
spec:
  entrypoint: transaction-pipeline
  templates:
  - name: bank-details
    container:
      args: [--transaction, '{{inputs.parameters.parties-involved-Output}}', --country-code,
        EE, --bank-code-length, '8', --account-number-length, '10', '----output-paths',
        /tmp/outputs/Output/data]
      command:
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        printf "%s" "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - |
        def bank_details(transaction, country_code='EE', bank_code_length=8, account_number_length=10):
            import random
            import string

            def generate_random_iban(country_code, bank_code_length, account_number_length):

                bank_code = ''.join(random.choices(string.digits, k=bank_code_length))
                account_number = ''.join(random.choices(string.digits, k=account_number_length))
                check_digits = ''.join(random.choices(string.digits, k=2))

                iban = f"{country_code}{check_digits} {bank_code} {account_number}"
                return iban

            def generate_random_bic():
                # Generate random BIC components
                bank_code = ''.join(random.choices(string.ascii_uppercase, k=4))
                country_code = ''.join(random.choices(string.ascii_uppercase, k=2))
                location_code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=2))
                branch_code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=3))

                # Construct the BIC
                bic = f"{bank_code}{country_code}{location_code}{branch_code}"
                return bic

            iban = generate_random_iban(country_code, bank_code_length, account_number_length)
            bic = generate_random_bic()

            transaction['iban'] = iban
            transaction['bic'] = bic

            return transaction

        def _serialize_json(obj) -> str:
            if isinstance(obj, str):
                return obj
            import json

            def default_serializer(obj):
                if hasattr(obj, 'to_struct'):
                    return obj.to_struct()
                else:
                    raise TypeError(
                        "Object of type '%s' is not JSON serializable and does not have .to_struct() method."
                        % obj.__class__.__name__)

            return json.dumps(obj, default=default_serializer, sort_keys=True)

        import json
        import argparse
        _parser = argparse.ArgumentParser(prog='Bank details', description='')
        _parser.add_argument("--transaction", dest="transaction", type=json.loads, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--country-code", dest="country_code", type=str, required=False, default=argparse.SUPPRESS)
        _parser.add_argument("--bank-code-length", dest="bank_code_length", type=int, required=False, default=argparse.SUPPRESS)
        _parser.add_argument("--account-number-length", dest="account_number_length", type=int, required=False, default=argparse.SUPPRESS)
        _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
        _parsed_args = vars(_parser.parse_args())
        _output_files = _parsed_args.pop("_output_paths", [])

        _outputs = bank_details(**_parsed_args)

        _outputs = [_outputs]

        _output_serializers = [
            _serialize_json,

        ]

        import os
        for idx, output_file in enumerate(_output_files):
            try:
                os.makedirs(os.path.dirname(output_file))
            except OSError:
                pass
            with open(output_file, 'w') as f:
                f.write(_output_serializers[idx](_outputs[idx]))
      image: python:3.7
    inputs:
      parameters:
      - {name: parties-involved-Output}
    outputs:
      parameters:
      - name: bank-details-Output
        valueFrom: {path: /tmp/outputs/Output/data}
      artifacts:
      - {name: bank-details-Output, path: /tmp/outputs/Output/data}
    metadata:
      labels:
        pipelines.kubeflow.org/kfp_sdk_version: 1.8.0
        pipelines.kubeflow.org/pipeline-sdk-type: kfp
        pipelines.kubeflow.org/enable_caching: "true"
      annotations: {pipelines.kubeflow.org/component_spec: '{"implementation": {"container":
          {"args": ["--transaction", {"inputValue": "transaction"}, {"if": {"cond":
          {"isPresent": "country_code"}, "then": ["--country-code", {"inputValue":
          "country_code"}]}}, {"if": {"cond": {"isPresent": "bank_code_length"}, "then":
          ["--bank-code-length", {"inputValue": "bank_code_length"}]}}, {"if": {"cond":
          {"isPresent": "account_number_length"}, "then": ["--account-number-length",
          {"inputValue": "account_number_length"}]}}, "----output-paths", {"outputPath":
          "Output"}], "command": ["sh", "-ec", "program_path=$(mktemp)\nprintf \"%s\"
          \"$0\" > \"$program_path\"\npython3 -u \"$program_path\" \"$@\"\n", "def
          bank_details(transaction, country_code=''EE'', bank_code_length=8, account_number_length=10):\n    import
          random\n    import string\n\n    def generate_random_iban(country_code,
          bank_code_length, account_number_length):\n\n        bank_code = ''''.join(random.choices(string.digits,
          k=bank_code_length))\n        account_number = ''''.join(random.choices(string.digits,
          k=account_number_length))\n        check_digits = ''''.join(random.choices(string.digits,
          k=2))\n\n        iban = f\"{country_code}{check_digits} {bank_code} {account_number}\"\n        return
          iban\n\n    def generate_random_bic():\n        # Generate random BIC components\n        bank_code
          = ''''.join(random.choices(string.ascii_uppercase, k=4))\n        country_code
          = ''''.join(random.choices(string.ascii_uppercase, k=2))\n        location_code
          = ''''.join(random.choices(string.ascii_uppercase + string.digits, k=2))\n        branch_code
          = ''''.join(random.choices(string.ascii_uppercase + string.digits, k=3))\n\n        #
          Construct the BIC\n        bic = f\"{bank_code}{country_code}{location_code}{branch_code}\"\n        return
          bic\n\n    iban = generate_random_iban(country_code, bank_code_length, account_number_length)\n    bic
          = generate_random_bic()\n\n    transaction[''iban''] = iban\n    transaction[''bic'']
          = bic\n\n    return transaction\n\ndef _serialize_json(obj) -> str:\n    if
          isinstance(obj, str):\n        return obj\n    import json\n\n    def default_serializer(obj):\n        if
          hasattr(obj, ''to_struct''):\n            return obj.to_struct()\n        else:\n            raise
          TypeError(\n                \"Object of type ''%s'' is not JSON serializable
          and does not have .to_struct() method.\"\n                % obj.__class__.__name__)\n\n    return
          json.dumps(obj, default=default_serializer, sort_keys=True)\n\nimport json\nimport
          argparse\n_parser = argparse.ArgumentParser(prog=''Bank details'', description='''')\n_parser.add_argument(\"--transaction\",
          dest=\"transaction\", type=json.loads, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--country-code\",
          dest=\"country_code\", type=str, required=False, default=argparse.SUPPRESS)\n_parser.add_argument(\"--bank-code-length\",
          dest=\"bank_code_length\", type=int, required=False, default=argparse.SUPPRESS)\n_parser.add_argument(\"--account-number-length\",
          dest=\"account_number_length\", type=int, required=False, default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\",
          dest=\"_output_paths\", type=str, nargs=1)\n_parsed_args = vars(_parser.parse_args())\n_output_files
          = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = bank_details(**_parsed_args)\n\n_outputs
          = [_outputs]\n\n_output_serializers = [\n    _serialize_json,\n\n]\n\nimport
          os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
          OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
          "image": "python:3.7"}}, "inputs": [{"name": "transaction", "type": "JsonObject"},
          {"default": "EE", "name": "country_code", "optional": true, "type": "String"},
          {"default": "8", "name": "bank_code_length", "optional": true, "type": "Integer"},
          {"default": "10", "name": "account_number_length", "optional": true, "type":
          "Integer"}], "name": "Bank details", "outputs": [{"name": "Output", "type":
          "JsonObject"}]}', pipelines.kubeflow.org/component_ref: '{}', pipelines.kubeflow.org/arguments.parameters: '{"account_number_length":
          "10", "bank_code_length": "8", "country_code": "EE", "transaction": "{{inputs.parameters.parties-involved-Output}}"}'}
  - name: business-names
    container:
      args: ['----output-paths', /tmp/outputs/Output/data]
      command:
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        printf "%s" "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - "def business_names():\n    import random\n    adjectives = [\n        \"\
        Advanced\", \"Innovative\", \"Creative\", \"Dynamic\", \"Efficient\", \"Global\"\
        , \n        \"Modern\", \"Smart\", \"Sustainable\", \"Unique\", \"Visionary\"\
        , \"Reliable\", \n        \"Proactive\", \"NextGen\", \"Future\"\n    ]\n\
        \    nouns = [\n        \"Solutions\", \"Technologies\", \"Services\", \"\
        Consulting\", \"Systems\", \n        \"Dynamics\", \"Enterprises\", \"Ventures\"\
        , \"Concepts\", \"Designs\", \"Strategies\",\n        \"Holdings\", \"Networks\"\
        , \"Group\", \"Partners\"\n    ]\n    suffixes = [\n        \"Inc.\", \"LLC\"\
        , \"Ltd.\", \"Corp.\", \"Co.\", \"Pty Ltd.\", \"AG\", \"GmbH\", \n       \
        \ \"Associates\", \"Holdings\"\n    ]\n\n    business_name1 = f\"{random.choice(adjectives)}\
        \ {random.choice(nouns)} {random.choice(suffixes)}\"\n    business_name2 =\
        \ f\"{random.choice(adjectives)} {random.choice(nouns)} {random.choice(suffixes)}\"\
        \n    return [business_name1, business_name2]\n\ndef _serialize_json(obj)\
        \ -> str:\n    if isinstance(obj, str):\n        return obj\n    import json\n\
        \n    def default_serializer(obj):\n        if hasattr(obj, 'to_struct'):\n\
        \            return obj.to_struct()\n        else:\n            raise TypeError(\n\
        \                \"Object of type '%s' is not JSON serializable and does not\
        \ have .to_struct() method.\"\n                % obj.__class__.__name__)\n\
        \n    return json.dumps(obj, default=default_serializer, sort_keys=True)\n\
        \nimport argparse\n_parser = argparse.ArgumentParser(prog='Business names',\
        \ description='')\n_parser.add_argument(\"----output-paths\", dest=\"_output_paths\"\
        , type=str, nargs=1)\n_parsed_args = vars(_parser.parse_args())\n_output_files\
        \ = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = business_names(**_parsed_args)\n\
        \n_outputs = [_outputs]\n\n_output_serializers = [\n    _serialize_json,\n\
        \n]\n\nimport os\nfor idx, output_file in enumerate(_output_files):\n    try:\n\
        \        os.makedirs(os.path.dirname(output_file))\n    except OSError:\n\
        \        pass\n    with open(output_file, 'w') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"
      image: python:3.7
    outputs:
      parameters:
      - name: business-names-Output
        valueFrom: {path: /tmp/outputs/Output/data}
      artifacts:
      - {name: business-names-Output, path: /tmp/outputs/Output/data}
    metadata:
      labels:
        pipelines.kubeflow.org/kfp_sdk_version: 1.8.0
        pipelines.kubeflow.org/pipeline-sdk-type: kfp
        pipelines.kubeflow.org/enable_caching: "true"
      annotations: {pipelines.kubeflow.org/component_spec: '{"implementation": {"container":
          {"args": ["----output-paths", {"outputPath": "Output"}], "command": ["sh",
          "-ec", "program_path=$(mktemp)\nprintf \"%s\" \"$0\" > \"$program_path\"\npython3
          -u \"$program_path\" \"$@\"\n", "def business_names():\n    import random\n    adjectives
          = [\n        \"Advanced\", \"Innovative\", \"Creative\", \"Dynamic\", \"Efficient\",
          \"Global\", \n        \"Modern\", \"Smart\", \"Sustainable\", \"Unique\",
          \"Visionary\", \"Reliable\", \n        \"Proactive\", \"NextGen\", \"Future\"\n    ]\n    nouns
          = [\n        \"Solutions\", \"Technologies\", \"Services\", \"Consulting\",
          \"Systems\", \n        \"Dynamics\", \"Enterprises\", \"Ventures\", \"Concepts\",
          \"Designs\", \"Strategies\",\n        \"Holdings\", \"Networks\", \"Group\",
          \"Partners\"\n    ]\n    suffixes = [\n        \"Inc.\", \"LLC\", \"Ltd.\",
          \"Corp.\", \"Co.\", \"Pty Ltd.\", \"AG\", \"GmbH\", \n        \"Associates\",
          \"Holdings\"\n    ]\n\n    business_name1 = f\"{random.choice(adjectives)}
          {random.choice(nouns)} {random.choice(suffixes)}\"\n    business_name2 =
          f\"{random.choice(adjectives)} {random.choice(nouns)} {random.choice(suffixes)}\"\n    return
          [business_name1, business_name2]\n\ndef _serialize_json(obj) -> str:\n    if
          isinstance(obj, str):\n        return obj\n    import json\n\n    def default_serializer(obj):\n        if
          hasattr(obj, ''to_struct''):\n            return obj.to_struct()\n        else:\n            raise
          TypeError(\n                \"Object of type ''%s'' is not JSON serializable
          and does not have .to_struct() method.\"\n                % obj.__class__.__name__)\n\n    return
          json.dumps(obj, default=default_serializer, sort_keys=True)\n\nimport argparse\n_parser
          = argparse.ArgumentParser(prog=''Business names'', description='''')\n_parser.add_argument(\"----output-paths\",
          dest=\"_output_paths\", type=str, nargs=1)\n_parsed_args = vars(_parser.parse_args())\n_output_files
          = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = business_names(**_parsed_args)\n\n_outputs
          = [_outputs]\n\n_output_serializers = [\n    _serialize_json,\n\n]\n\nimport
          os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
          OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
          "image": "python:3.7"}}, "name": "Business names", "outputs": [{"name":
          "Output", "type": "JsonArray"}]}', pipelines.kubeflow.org/component_ref: '{}'}
  - name: card-details
    container:
      args: [--transaction, '{{inputs.parameters.parties-involved-Output}}', '----output-paths',
        /tmp/outputs/Output/data]
      command:
      - sh
      - -c
      - (PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet --no-warn-script-location
        'faker' || PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet
        --no-warn-script-location 'faker' --user) && "$0" "$@"
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        printf "%s" "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - |
        def card_details(transaction):
            from faker import Faker
            import random

            fake = Faker()
            transaction['card_number'] = fake.credit_card_number()
            transaction['card_type'] = random.choice(['Visa', 'MasterCard', 'American Express', 'Discover', 'JCB'])

            return transaction

        def _serialize_json(obj) -> str:
            if isinstance(obj, str):
                return obj
            import json

            def default_serializer(obj):
                if hasattr(obj, 'to_struct'):
                    return obj.to_struct()
                else:
                    raise TypeError(
                        "Object of type '%s' is not JSON serializable and does not have .to_struct() method."
                        % obj.__class__.__name__)

            return json.dumps(obj, default=default_serializer, sort_keys=True)

        import json
        import argparse
        _parser = argparse.ArgumentParser(prog='Card details', description='')
        _parser.add_argument("--transaction", dest="transaction", type=json.loads, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
        _parsed_args = vars(_parser.parse_args())
        _output_files = _parsed_args.pop("_output_paths", [])

        _outputs = card_details(**_parsed_args)

        _outputs = [_outputs]

        _output_serializers = [
            _serialize_json,

        ]

        import os
        for idx, output_file in enumerate(_output_files):
            try:
                os.makedirs(os.path.dirname(output_file))
            except OSError:
                pass
            with open(output_file, 'w') as f:
                f.write(_output_serializers[idx](_outputs[idx]))
      image: python:3.7
    inputs:
      parameters:
      - {name: parties-involved-Output}
    outputs:
      parameters:
      - name: card-details-Output
        valueFrom: {path: /tmp/outputs/Output/data}
      artifacts:
      - {name: card-details-Output, path: /tmp/outputs/Output/data}
    metadata:
      labels:
        pipelines.kubeflow.org/kfp_sdk_version: 1.8.0
        pipelines.kubeflow.org/pipeline-sdk-type: kfp
        pipelines.kubeflow.org/enable_caching: "true"
      annotations: {pipelines.kubeflow.org/component_spec: '{"implementation": {"container":
          {"args": ["--transaction", {"inputValue": "transaction"}, "----output-paths",
          {"outputPath": "Output"}], "command": ["sh", "-c", "(PIP_DISABLE_PIP_VERSION_CHECK=1
          python3 -m pip install --quiet --no-warn-script-location ''faker'' || PIP_DISABLE_PIP_VERSION_CHECK=1
          python3 -m pip install --quiet --no-warn-script-location ''faker'' --user)
          && \"$0\" \"$@\"", "sh", "-ec", "program_path=$(mktemp)\nprintf \"%s\" \"$0\"
          > \"$program_path\"\npython3 -u \"$program_path\" \"$@\"\n", "def card_details(transaction):\n    from
          faker import Faker\n    import random\n\n    fake = Faker()\n    transaction[''card_number'']
          = fake.credit_card_number()\n    transaction[''card_type''] = random.choice([''Visa'',
          ''MasterCard'', ''American Express'', ''Discover'', ''JCB''])\n\n    return
          transaction\n\ndef _serialize_json(obj) -> str:\n    if isinstance(obj,
          str):\n        return obj\n    import json\n\n    def default_serializer(obj):\n        if
          hasattr(obj, ''to_struct''):\n            return obj.to_struct()\n        else:\n            raise
          TypeError(\n                \"Object of type ''%s'' is not JSON serializable
          and does not have .to_struct() method.\"\n                % obj.__class__.__name__)\n\n    return
          json.dumps(obj, default=default_serializer, sort_keys=True)\n\nimport json\nimport
          argparse\n_parser = argparse.ArgumentParser(prog=''Card details'', description='''')\n_parser.add_argument(\"--transaction\",
          dest=\"transaction\", type=json.loads, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\",
          dest=\"_output_paths\", type=str, nargs=1)\n_parsed_args = vars(_parser.parse_args())\n_output_files
          = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = card_details(**_parsed_args)\n\n_outputs
          = [_outputs]\n\n_output_serializers = [\n    _serialize_json,\n\n]\n\nimport
          os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
          OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
          "image": "python:3.7"}}, "inputs": [{"name": "transaction", "type": "JsonObject"}],
          "name": "Card details", "outputs": [{"name": "Output", "type": "JsonObject"}]}',
        pipelines.kubeflow.org/component_ref: '{}', pipelines.kubeflow.org/arguments.parameters: '{"transaction":
          "{{inputs.parameters.parties-involved-Output}}"}'}
  - name: condition-1
    inputs:
      parameters:
      - {name: parties-involved-Output}
    dag:
      tasks:
      - name: card-details
        template: card-details
        arguments:
          parameters:
          - {name: parties-involved-Output, value: '{{inputs.parameters.parties-involved-Output}}'}
      - name: send-transaction
        template: send-transaction
        dependencies: [card-details]
        arguments:
          parameters:
          - {name: card-details-Output, value: '{{tasks.card-details.outputs.parameters.card-details-Output}}'}
  - name: condition-2
    inputs:
      parameters:
      - {name: parties-involved-Output}
    dag:
      tasks:
      - name: bank-details
        template: bank-details
        arguments:
          parameters:
          - {name: parties-involved-Output, value: '{{inputs.parameters.parties-involved-Output}}'}
      - name: send-transaction-2
        template: send-transaction-2
        dependencies: [bank-details]
        arguments:
          parameters:
          - {name: bank-details-Output, value: '{{tasks.bank-details.outputs.parameters.bank-details-Output}}'}
  - name: extract-payment-method
    container:
      args: [--parties-info, '{{inputs.parameters.parties-involved-Output}}', '----output-paths',
        /tmp/outputs/Output/data]
      command:
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        printf "%s" "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - |
        def extract_payment_method(parties_info):
            return parties_info['payment_method']

        def _serialize_str(str_value: str) -> str:
            if not isinstance(str_value, str):
                raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                    str(str_value), str(type(str_value))))
            return str_value

        import json
        import argparse
        _parser = argparse.ArgumentParser(prog='Extract payment method', description='')
        _parser.add_argument("--parties-info", dest="parties_info", type=json.loads, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
        _parsed_args = vars(_parser.parse_args())
        _output_files = _parsed_args.pop("_output_paths", [])

        _outputs = extract_payment_method(**_parsed_args)

        _outputs = [_outputs]

        _output_serializers = [
            _serialize_str,

        ]

        import os
        for idx, output_file in enumerate(_output_files):
            try:
                os.makedirs(os.path.dirname(output_file))
            except OSError:
                pass
            with open(output_file, 'w') as f:
                f.write(_output_serializers[idx](_outputs[idx]))
      image: python:3.7
    inputs:
      parameters:
      - {name: parties-involved-Output}
    outputs:
      parameters:
      - name: extract-payment-method-Output
        valueFrom: {path: /tmp/outputs/Output/data}
      artifacts:
      - {name: extract-payment-method-Output, path: /tmp/outputs/Output/data}
    metadata:
      labels:
        pipelines.kubeflow.org/kfp_sdk_version: 1.8.0
        pipelines.kubeflow.org/pipeline-sdk-type: kfp
        pipelines.kubeflow.org/enable_caching: "true"
      annotations: {pipelines.kubeflow.org/component_spec: '{"implementation": {"container":
          {"args": ["--parties-info", {"inputValue": "parties_info"}, "----output-paths",
          {"outputPath": "Output"}], "command": ["sh", "-ec", "program_path=$(mktemp)\nprintf
          \"%s\" \"$0\" > \"$program_path\"\npython3 -u \"$program_path\" \"$@\"\n",
          "def extract_payment_method(parties_info):\n    return parties_info[''payment_method'']\n\ndef
          _serialize_str(str_value: str) -> str:\n    if not isinstance(str_value,
          str):\n        raise TypeError(''Value \"{}\" has type \"{}\" instead of
          str.''.format(\n            str(str_value), str(type(str_value))))\n    return
          str_value\n\nimport json\nimport argparse\n_parser = argparse.ArgumentParser(prog=''Extract
          payment method'', description='''')\n_parser.add_argument(\"--parties-info\",
          dest=\"parties_info\", type=json.loads, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\",
          dest=\"_output_paths\", type=str, nargs=1)\n_parsed_args = vars(_parser.parse_args())\n_output_files
          = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = extract_payment_method(**_parsed_args)\n\n_outputs
          = [_outputs]\n\n_output_serializers = [\n    _serialize_str,\n\n]\n\nimport
          os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
          OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
          "image": "python:3.7"}}, "inputs": [{"name": "parties_info", "type": "JsonObject"}],
          "name": "Extract payment method", "outputs": [{"name": "Output", "type":
          "String"}]}', pipelines.kubeflow.org/component_ref: '{}', pipelines.kubeflow.org/arguments.parameters: '{"parties_info":
          "{{inputs.parameters.parties-involved-Output}}"}'}
  - name: parties-involved
    container:
      args: [--transaction, '{{inputs.parameters.transaction-details-Output}}', --business-names,
        '{{inputs.parameters.business-names-Output}}', '----output-paths', /tmp/outputs/Output/data]
      command:
      - sh
      - -c
      - (PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet --no-warn-script-location
        'faker' || PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet
        --no-warn-script-location 'faker' --user) && "$0" "$@"
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        printf "%s" "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - |
        def parties_involved(transaction, business_names):
            # Possible types on transactions
            # 1. Person to Person
            # 2. Business to Business
            # 3. Person to Business
            # 4. Business to Person
            import random
            from faker import Faker
            import uuid

            fake = Faker()
            type = random.randint(1, 4)

            if type == 1:
                sender_name = fake.name()
                receiver_name = fake.name()
            elif type == 2:
                sender_name = business_names[0]
                receiver_name = business_names[1]
            elif type == 3:
                sender_name = fake.name()
                receiver_name = business_names[1]
            elif type == 4:
                sender_name = business_names[0]
                receiver_name = fake.name()

            transaction['sender_id'] = str(uuid.uuid4())
            transaction['sender_name'] = sender_name

            transaction['receiver_id'] = str(uuid.uuid4())
            transaction['receiver_name'] = receiver_name

            transaction['payment_method'] = random.choice(['CARD', 'TRANSFER'])

            return transaction

        def _serialize_json(obj) -> str:
            if isinstance(obj, str):
                return obj
            import json

            def default_serializer(obj):
                if hasattr(obj, 'to_struct'):
                    return obj.to_struct()
                else:
                    raise TypeError(
                        "Object of type '%s' is not JSON serializable and does not have .to_struct() method."
                        % obj.__class__.__name__)

            return json.dumps(obj, default=default_serializer, sort_keys=True)

        import json
        import argparse
        _parser = argparse.ArgumentParser(prog='Parties involved', description='')
        _parser.add_argument("--transaction", dest="transaction", type=json.loads, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--business-names", dest="business_names", type=json.loads, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
        _parsed_args = vars(_parser.parse_args())
        _output_files = _parsed_args.pop("_output_paths", [])

        _outputs = parties_involved(**_parsed_args)

        _outputs = [_outputs]

        _output_serializers = [
            _serialize_json,

        ]

        import os
        for idx, output_file in enumerate(_output_files):
            try:
                os.makedirs(os.path.dirname(output_file))
            except OSError:
                pass
            with open(output_file, 'w') as f:
                f.write(_output_serializers[idx](_outputs[idx]))
      image: python:3.7
    inputs:
      parameters:
      - {name: business-names-Output}
      - {name: transaction-details-Output}
    outputs:
      parameters:
      - name: parties-involved-Output
        valueFrom: {path: /tmp/outputs/Output/data}
      artifacts:
      - {name: parties-involved-Output, path: /tmp/outputs/Output/data}
    metadata:
      labels:
        pipelines.kubeflow.org/kfp_sdk_version: 1.8.0
        pipelines.kubeflow.org/pipeline-sdk-type: kfp
        pipelines.kubeflow.org/enable_caching: "true"
      annotations: {pipelines.kubeflow.org/component_spec: '{"implementation": {"container":
          {"args": ["--transaction", {"inputValue": "transaction"}, "--business-names",
          {"inputValue": "business_names"}, "----output-paths", {"outputPath": "Output"}],
          "command": ["sh", "-c", "(PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip
          install --quiet --no-warn-script-location ''faker'' || PIP_DISABLE_PIP_VERSION_CHECK=1
          python3 -m pip install --quiet --no-warn-script-location ''faker'' --user)
          && \"$0\" \"$@\"", "sh", "-ec", "program_path=$(mktemp)\nprintf \"%s\" \"$0\"
          > \"$program_path\"\npython3 -u \"$program_path\" \"$@\"\n", "def parties_involved(transaction,
          business_names):\n    # Possible types on transactions\n    # 1. Person
          to Person\n    # 2. Business to Business\n    # 3. Person to Business\n    #
          4. Business to Person\n    import random\n    from faker import Faker\n    import
          uuid\n\n    fake = Faker()\n    type = random.randint(1, 4)\n\n    if type
          == 1:\n        sender_name = fake.name()\n        receiver_name = fake.name()\n    elif
          type == 2:\n        sender_name = business_names[0]\n        receiver_name
          = business_names[1]\n    elif type == 3:\n        sender_name = fake.name()\n        receiver_name
          = business_names[1]\n    elif type == 4:\n        sender_name = business_names[0]\n        receiver_name
          = fake.name()\n\n    transaction[''sender_id''] = str(uuid.uuid4())\n    transaction[''sender_name'']
          = sender_name\n\n    transaction[''receiver_id''] = str(uuid.uuid4())\n    transaction[''receiver_name'']
          = receiver_name\n\n    transaction[''payment_method''] = random.choice([''CARD'',
          ''TRANSFER''])\n\n    return transaction\n\ndef _serialize_json(obj) ->
          str:\n    if isinstance(obj, str):\n        return obj\n    import json\n\n    def
          default_serializer(obj):\n        if hasattr(obj, ''to_struct''):\n            return
          obj.to_struct()\n        else:\n            raise TypeError(\n                \"Object
          of type ''%s'' is not JSON serializable and does not have .to_struct() method.\"\n                %
          obj.__class__.__name__)\n\n    return json.dumps(obj, default=default_serializer,
          sort_keys=True)\n\nimport json\nimport argparse\n_parser = argparse.ArgumentParser(prog=''Parties
          involved'', description='''')\n_parser.add_argument(\"--transaction\", dest=\"transaction\",
          type=json.loads, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--business-names\",
          dest=\"business_names\", type=json.loads, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\",
          dest=\"_output_paths\", type=str, nargs=1)\n_parsed_args = vars(_parser.parse_args())\n_output_files
          = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = parties_involved(**_parsed_args)\n\n_outputs
          = [_outputs]\n\n_output_serializers = [\n    _serialize_json,\n\n]\n\nimport
          os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
          OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
          "image": "python:3.7"}}, "inputs": [{"name": "transaction", "type": "JsonObject"},
          {"name": "business_names", "type": "JsonArray"}], "name": "Parties involved",
          "outputs": [{"name": "Output", "type": "JsonObject"}]}', pipelines.kubeflow.org/component_ref: '{}',
        pipelines.kubeflow.org/arguments.parameters: '{"business_names": "{{inputs.parameters.business-names-Output}}",
          "transaction": "{{inputs.parameters.transaction-details-Output}}"}'}
  - name: send-transaction
    container:
      args: [--transaction, '{{inputs.parameters.card-details-Output}}', --host-ip,
        192.168.76.119, --port, '3000']
      command:
      - sh
      - -c
      - (PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet --no-warn-script-location
        'requests' || PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet
        --no-warn-script-location 'requests' --user) && "$0" "$@"
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        printf "%s" "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - |
        def send_transaction(transaction, host_ip, port):
            import time
            import requests

            def wait_for_port(host, port, timeout = 60):
                """
                Wait until the port on the host is open or the timeout is reached.
                """
                import socket

                start_time = time.time()
                while time.time() - start_time < timeout:
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                        result = sock.connect_ex((host, port))
                        if result == 0:
                            return True
                        time.sleep(1)
                return False

            """
            Waits until the service port on the host machine is open and then sends a POST request.
            """
            api_url = f'http://{host_ip}:{port}'

            # Wait until the port is available
            if wait_for_port(host_ip, port):
                print(f"Port {port} on host {host_ip} is open. Sending POST request...")

                try:
                    headers = {
                        'Content-Type': 'application/json'
                    }
                    response = requests.post(api_url, json=transaction, headers=headers)
                    response.raise_for_status()
                    print(f'Payment successful! Response: {response.json()}')
                except requests.exceptions.RequestException as e:
                    print(f'Error: {e}')
            else:
                print(f"Port {port} on host {host_ip} is not open after waiting.")

        import json
        import argparse
        _parser = argparse.ArgumentParser(prog='Send transaction', description='')
        _parser.add_argument("--transaction", dest="transaction", type=json.loads, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--host-ip", dest="host_ip", type=str, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--port", dest="port", type=int, required=True, default=argparse.SUPPRESS)
        _parsed_args = vars(_parser.parse_args())

        _outputs = send_transaction(**_parsed_args)
      image: python:3.7
    inputs:
      parameters:
      - {name: card-details-Output}
    metadata:
      labels:
        pipelines.kubeflow.org/kfp_sdk_version: 1.8.0
        pipelines.kubeflow.org/pipeline-sdk-type: kfp
        pipelines.kubeflow.org/enable_caching: "true"
      annotations: {pipelines.kubeflow.org/component_spec: '{"implementation": {"container":
          {"args": ["--transaction", {"inputValue": "transaction"}, "--host-ip", {"inputValue":
          "host_ip"}, "--port", {"inputValue": "port"}], "command": ["sh", "-c", "(PIP_DISABLE_PIP_VERSION_CHECK=1
          python3 -m pip install --quiet --no-warn-script-location ''requests'' ||
          PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet --no-warn-script-location
          ''requests'' --user) && \"$0\" \"$@\"", "sh", "-ec", "program_path=$(mktemp)\nprintf
          \"%s\" \"$0\" > \"$program_path\"\npython3 -u \"$program_path\" \"$@\"\n",
          "def send_transaction(transaction, host_ip, port):\n    import time\n    import
          requests\n\n    def wait_for_port(host, port, timeout = 60):\n        \"\"\"\n        Wait
          until the port on the host is open or the timeout is reached.\n        \"\"\"\n        import
          socket\n\n        start_time = time.time()\n        while time.time() -
          start_time < timeout:\n            with socket.socket(socket.AF_INET, socket.SOCK_STREAM)
          as sock:\n                result = sock.connect_ex((host, port))\n                if
          result == 0:\n                    return True\n                time.sleep(1)\n        return
          False\n\n    \"\"\"\n    Waits until the service port on the host machine
          is open and then sends a POST request.\n    \"\"\"\n    api_url = f''http://{host_ip}:{port}''\n\n    #
          Wait until the port is available\n    if wait_for_port(host_ip, port):\n        print(f\"Port
          {port} on host {host_ip} is open. Sending POST request...\")\n\n        try:\n            headers
          = {\n                ''Content-Type'': ''application/json''\n            }\n            response
          = requests.post(api_url, json=transaction, headers=headers)\n            response.raise_for_status()\n            print(f''Payment
          successful! Response: {response.json()}'')\n        except requests.exceptions.RequestException
          as e:\n            print(f''Error: {e}'')\n    else:\n        print(f\"Port
          {port} on host {host_ip} is not open after waiting.\")\n\nimport json\nimport
          argparse\n_parser = argparse.ArgumentParser(prog=''Send transaction'', description='''')\n_parser.add_argument(\"--transaction\",
          dest=\"transaction\", type=json.loads, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--host-ip\",
          dest=\"host_ip\", type=str, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--port\",
          dest=\"port\", type=int, required=True, default=argparse.SUPPRESS)\n_parsed_args
          = vars(_parser.parse_args())\n\n_outputs = send_transaction(**_parsed_args)\n"],
          "image": "python:3.7"}}, "inputs": [{"name": "transaction", "type": "JsonObject"},
          {"name": "host_ip", "type": "String"}, {"name": "port", "type": "Integer"}],
          "name": "Send transaction"}', pipelines.kubeflow.org/component_ref: '{}',
        pipelines.kubeflow.org/arguments.parameters: '{"host_ip": "192.168.76.119",
          "port": "3000", "transaction": "{{inputs.parameters.card-details-Output}}"}'}
  - name: send-transaction-2
    container:
      args: [--transaction, '{{inputs.parameters.bank-details-Output}}', --host-ip,
        192.168.76.119, --port, '3000']
      command:
      - sh
      - -c
      - (PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet --no-warn-script-location
        'requests' || PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet
        --no-warn-script-location 'requests' --user) && "$0" "$@"
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        printf "%s" "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - |
        def send_transaction(transaction, host_ip, port):
            import time
            import requests

            def wait_for_port(host, port, timeout = 60):
                """
                Wait until the port on the host is open or the timeout is reached.
                """
                import socket

                start_time = time.time()
                while time.time() - start_time < timeout:
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                        result = sock.connect_ex((host, port))
                        if result == 0:
                            return True
                        time.sleep(1)
                return False

            """
            Waits until the service port on the host machine is open and then sends a POST request.
            """
            api_url = f'http://{host_ip}:{port}'

            # Wait until the port is available
            if wait_for_port(host_ip, port):
                print(f"Port {port} on host {host_ip} is open. Sending POST request...")

                try:
                    headers = {
                        'Content-Type': 'application/json'
                    }
                    response = requests.post(api_url, json=transaction, headers=headers)
                    response.raise_for_status()
                    print(f'Payment successful! Response: {response.json()}')
                except requests.exceptions.RequestException as e:
                    print(f'Error: {e}')
            else:
                print(f"Port {port} on host {host_ip} is not open after waiting.")

        import json
        import argparse
        _parser = argparse.ArgumentParser(prog='Send transaction', description='')
        _parser.add_argument("--transaction", dest="transaction", type=json.loads, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--host-ip", dest="host_ip", type=str, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--port", dest="port", type=int, required=True, default=argparse.SUPPRESS)
        _parsed_args = vars(_parser.parse_args())

        _outputs = send_transaction(**_parsed_args)
      image: python:3.7
    inputs:
      parameters:
      - {name: bank-details-Output}
    metadata:
      labels:
        pipelines.kubeflow.org/kfp_sdk_version: 1.8.0
        pipelines.kubeflow.org/pipeline-sdk-type: kfp
        pipelines.kubeflow.org/enable_caching: "true"
      annotations: {pipelines.kubeflow.org/component_spec: '{"implementation": {"container":
          {"args": ["--transaction", {"inputValue": "transaction"}, "--host-ip", {"inputValue":
          "host_ip"}, "--port", {"inputValue": "port"}], "command": ["sh", "-c", "(PIP_DISABLE_PIP_VERSION_CHECK=1
          python3 -m pip install --quiet --no-warn-script-location ''requests'' ||
          PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet --no-warn-script-location
          ''requests'' --user) && \"$0\" \"$@\"", "sh", "-ec", "program_path=$(mktemp)\nprintf
          \"%s\" \"$0\" > \"$program_path\"\npython3 -u \"$program_path\" \"$@\"\n",
          "def send_transaction(transaction, host_ip, port):\n    import time\n    import
          requests\n\n    def wait_for_port(host, port, timeout = 60):\n        \"\"\"\n        Wait
          until the port on the host is open or the timeout is reached.\n        \"\"\"\n        import
          socket\n\n        start_time = time.time()\n        while time.time() -
          start_time < timeout:\n            with socket.socket(socket.AF_INET, socket.SOCK_STREAM)
          as sock:\n                result = sock.connect_ex((host, port))\n                if
          result == 0:\n                    return True\n                time.sleep(1)\n        return
          False\n\n    \"\"\"\n    Waits until the service port on the host machine
          is open and then sends a POST request.\n    \"\"\"\n    api_url = f''http://{host_ip}:{port}''\n\n    #
          Wait until the port is available\n    if wait_for_port(host_ip, port):\n        print(f\"Port
          {port} on host {host_ip} is open. Sending POST request...\")\n\n        try:\n            headers
          = {\n                ''Content-Type'': ''application/json''\n            }\n            response
          = requests.post(api_url, json=transaction, headers=headers)\n            response.raise_for_status()\n            print(f''Payment
          successful! Response: {response.json()}'')\n        except requests.exceptions.RequestException
          as e:\n            print(f''Error: {e}'')\n    else:\n        print(f\"Port
          {port} on host {host_ip} is not open after waiting.\")\n\nimport json\nimport
          argparse\n_parser = argparse.ArgumentParser(prog=''Send transaction'', description='''')\n_parser.add_argument(\"--transaction\",
          dest=\"transaction\", type=json.loads, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--host-ip\",
          dest=\"host_ip\", type=str, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--port\",
          dest=\"port\", type=int, required=True, default=argparse.SUPPRESS)\n_parsed_args
          = vars(_parser.parse_args())\n\n_outputs = send_transaction(**_parsed_args)\n"],
          "image": "python:3.7"}}, "inputs": [{"name": "transaction", "type": "JsonObject"},
          {"name": "host_ip", "type": "String"}, {"name": "port", "type": "Integer"}],
          "name": "Send transaction"}', pipelines.kubeflow.org/component_ref: '{}',
        pipelines.kubeflow.org/arguments.parameters: '{"host_ip": "192.168.76.119",
          "port": "3000", "transaction": "{{inputs.parameters.bank-details-Output}}"}'}
  - name: transaction-details
    container:
      args: [--start-date, '2000-01-01', --end-date, '2024-01-01', '----output-paths',
        /tmp/outputs/Output/data]
      command:
      - sh
      - -c
      - (PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet --no-warn-script-location
        'pandas' || PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet
        --no-warn-script-location 'pandas' --user) && "$0" "$@"
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        printf "%s" "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - |
        def transaction_details(start_date, end_date):
            import uuid
            import datetime
            import random
            import time
            import pandas as pd

            currencies = [
                'USD', 'EUR', 'GBP', 'JPY', 'CHF', 'CAD', 'AUD', 'NZD', 'CNY', 'INR',
                'RUB', 'BRL', 'ZAR', 'SGD', 'HKD', 'MXN', 'NOK', 'SEK', 'DKK', 'PLN'
            ]

            def random_timestamp(start_date_str, end_date_str, date_format='%Y-%m-%d'):
                # Convert date strings to datetime objects
                start_date = datetime.datetime.strptime(start_date_str, date_format)
                end_date = datetime.datetime.strptime(end_date_str, date_format)

                # Convert datetime objects to Unix timestamps
                start_timestamp = int(time.mktime(start_date.timetuple()))
                end_timestamp = int(time.mktime(end_date.timetuple()))

                # Generate a random timestamp between the start and end timestamps
                random_timestamp = random.randint(start_timestamp, end_timestamp)

                # Convert the random timestamp back to a datetime object
                random_date = datetime.datetime.fromtimestamp(random_timestamp)

                return random_date

            transaction = {
                'transaction_id':str(uuid.uuid4()),
                'timestamp':str(random_timestamp(start_date, end_date)),
                'amount':round(random.uniform(0, 10000), 2),
                'currency':random.choice(currencies),
                'payment_method':random.choice(['CARD', 'TRANSFER'])
                }
            return transaction

        def _serialize_json(obj) -> str:
            if isinstance(obj, str):
                return obj
            import json

            def default_serializer(obj):
                if hasattr(obj, 'to_struct'):
                    return obj.to_struct()
                else:
                    raise TypeError(
                        "Object of type '%s' is not JSON serializable and does not have .to_struct() method."
                        % obj.__class__.__name__)

            return json.dumps(obj, default=default_serializer, sort_keys=True)

        import argparse
        _parser = argparse.ArgumentParser(prog='Transaction details', description='')
        _parser.add_argument("--start-date", dest="start_date", type=str, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--end-date", dest="end_date", type=str, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
        _parsed_args = vars(_parser.parse_args())
        _output_files = _parsed_args.pop("_output_paths", [])

        _outputs = transaction_details(**_parsed_args)

        _outputs = [_outputs]

        _output_serializers = [
            _serialize_json,

        ]

        import os
        for idx, output_file in enumerate(_output_files):
            try:
                os.makedirs(os.path.dirname(output_file))
            except OSError:
                pass
            with open(output_file, 'w') as f:
                f.write(_output_serializers[idx](_outputs[idx]))
      image: python:3.7
    outputs:
      parameters:
      - name: transaction-details-Output
        valueFrom: {path: /tmp/outputs/Output/data}
      artifacts:
      - {name: transaction-details-Output, path: /tmp/outputs/Output/data}
    metadata:
      labels:
        pipelines.kubeflow.org/kfp_sdk_version: 1.8.0
        pipelines.kubeflow.org/pipeline-sdk-type: kfp
        pipelines.kubeflow.org/enable_caching: "true"
      annotations: {pipelines.kubeflow.org/component_spec: '{"implementation": {"container":
          {"args": ["--start-date", {"inputValue": "start_date"}, "--end-date", {"inputValue":
          "end_date"}, "----output-paths", {"outputPath": "Output"}], "command": ["sh",
          "-c", "(PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet --no-warn-script-location
          ''pandas'' || PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet
          --no-warn-script-location ''pandas'' --user) && \"$0\" \"$@\"", "sh", "-ec",
          "program_path=$(mktemp)\nprintf \"%s\" \"$0\" > \"$program_path\"\npython3
          -u \"$program_path\" \"$@\"\n", "def transaction_details(start_date, end_date):\n    import
          uuid\n    import datetime\n    import random\n    import time\n    import
          pandas as pd\n\n    currencies = [\n        ''USD'', ''EUR'', ''GBP'', ''JPY'',
          ''CHF'', ''CAD'', ''AUD'', ''NZD'', ''CNY'', ''INR'',\n        ''RUB'',
          ''BRL'', ''ZAR'', ''SGD'', ''HKD'', ''MXN'', ''NOK'', ''SEK'', ''DKK'',
          ''PLN''\n    ]\n\n    def random_timestamp(start_date_str, end_date_str,
          date_format=''%Y-%m-%d''):\n        # Convert date strings to datetime objects\n        start_date
          = datetime.datetime.strptime(start_date_str, date_format)\n        end_date
          = datetime.datetime.strptime(end_date_str, date_format)\n\n        # Convert
          datetime objects to Unix timestamps\n        start_timestamp = int(time.mktime(start_date.timetuple()))\n        end_timestamp
          = int(time.mktime(end_date.timetuple()))\n\n        # Generate a random
          timestamp between the start and end timestamps\n        random_timestamp
          = random.randint(start_timestamp, end_timestamp)\n\n        # Convert the
          random timestamp back to a datetime object\n        random_date = datetime.datetime.fromtimestamp(random_timestamp)\n\n        return
          random_date\n\n    transaction = {\n        ''transaction_id'':str(uuid.uuid4()),\n        ''timestamp'':str(random_timestamp(start_date,
          end_date)),\n        ''amount'':round(random.uniform(0, 10000), 2),\n        ''currency'':random.choice(currencies),\n        ''payment_method'':random.choice([''CARD'',
          ''TRANSFER''])\n        }\n    return transaction\n\ndef _serialize_json(obj)
          -> str:\n    if isinstance(obj, str):\n        return obj\n    import json\n\n    def
          default_serializer(obj):\n        if hasattr(obj, ''to_struct''):\n            return
          obj.to_struct()\n        else:\n            raise TypeError(\n                \"Object
          of type ''%s'' is not JSON serializable and does not have .to_struct() method.\"\n                %
          obj.__class__.__name__)\n\n    return json.dumps(obj, default=default_serializer,
          sort_keys=True)\n\nimport argparse\n_parser = argparse.ArgumentParser(prog=''Transaction
          details'', description='''')\n_parser.add_argument(\"--start-date\", dest=\"start_date\",
          type=str, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--end-date\",
          dest=\"end_date\", type=str, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\",
          dest=\"_output_paths\", type=str, nargs=1)\n_parsed_args = vars(_parser.parse_args())\n_output_files
          = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = transaction_details(**_parsed_args)\n\n_outputs
          = [_outputs]\n\n_output_serializers = [\n    _serialize_json,\n\n]\n\nimport
          os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
          OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
          "image": "python:3.7"}}, "inputs": [{"name": "start_date", "type": "String"},
          {"name": "end_date", "type": "String"}], "name": "Transaction details",
          "outputs": [{"name": "Output", "type": "JsonObject"}]}', pipelines.kubeflow.org/component_ref: '{}',
        pipelines.kubeflow.org/arguments.parameters: '{"end_date": "2024-01-01", "start_date":
          "2000-01-01"}'}
  - name: transaction-pipeline
    dag:
      tasks:
      - {name: business-names, template: business-names}
      - name: condition-1
        template: condition-1
        when: '"{{tasks.extract-payment-method.outputs.parameters.extract-payment-method-Output}}"
          == "CARD"'
        dependencies: [extract-payment-method, parties-involved]
        arguments:
          parameters:
          - {name: parties-involved-Output, value: '{{tasks.parties-involved.outputs.parameters.parties-involved-Output}}'}
      - name: condition-2
        template: condition-2
        when: '"{{tasks.extract-payment-method.outputs.parameters.extract-payment-method-Output}}"
          == "TRANSFER"'
        dependencies: [extract-payment-method, parties-involved]
        arguments:
          parameters:
          - {name: parties-involved-Output, value: '{{tasks.parties-involved.outputs.parameters.parties-involved-Output}}'}
      - name: extract-payment-method
        template: extract-payment-method
        dependencies: [parties-involved]
        arguments:
          parameters:
          - {name: parties-involved-Output, value: '{{tasks.parties-involved.outputs.parameters.parties-involved-Output}}'}
      - name: parties-involved
        template: parties-involved
        dependencies: [business-names, transaction-details]
        arguments:
          parameters:
          - {name: business-names-Output, value: '{{tasks.business-names.outputs.parameters.business-names-Output}}'}
          - {name: transaction-details-Output, value: '{{tasks.transaction-details.outputs.parameters.transaction-details-Output}}'}
      - {name: transaction-details, template: transaction-details}
  arguments:
    parameters: []
  serviceAccountName: pipeline-runner
